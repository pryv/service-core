// @flow

const path = require('path');
const fs = require('fs');

const bluebird = require('bluebird');

// Tools for interacting with a service definition written in protobuf 3. 

class Definition {
  definitionPath: string;       // original load path for this definition
  
  // Loads a protobuf3 service definition file and returns an instance of
  // `Definition`.
  // 
  static load(path: string): Definition {
    return new Definition(path); 
  }

  constructor(path: string) {
    this.definitionPath = path; 
  }
  
  // Compiles this definition into a flow-type signature that describes the
  // protocol and writes a valid flow type signature into the `filename` given.
  // If `path` is also specified, it is used as a target path. 
  // 
  // The generated definition file will contain interface exports for all
  // relevant types in the definition file so you can annotate the javascript
  // code and make sure your usage corresponds to the current service
  // definition. 
  // 
  // For example, a protobuf 3 file containing this message: 
  // 
  //    message SearchResponse {
  //      repeated Result results = 1;
  //    }
  // 
  // will compile to: 
  // 
  //    export interface SearchResponse {
  //      results: Array<Result>;
  //    }
  // 
  // Note that your protobuf service description should be closed and not
  // require external types, unless you import those from elsewhere. 
  // 
  async writeTypeSignature(filename: string, targetPath?: string) {
    const sigPath = targetPath || path.dirname(this.definitionPath);
    const sigFilename = path.join(sigPath, filename);
    
    await File.open(sigFilename, 'w+', (file) => {
      file.writeln('// @flow');
      file.writeln('');
      file.writeln(`// THIS FILE IS AUTOGENERATED FROM ${this.definitionPath}`);
      file.writeln('// PLEASE DONT EDIT MANUALLY');
      file.writeln('');
    });
  }
}

const fileOpen = bluebird.promisify(fs.open);
const fileClose = bluebird.promisify(fs.close);
const fileWrite = bluebird.promisify(fs.write);

// A thin wrapper around 'fs', doing resource disposal. 
// 
class File {
  fd: number;         // The file descriptor returned by fs.open. 
  
  // Opens a file (`fs.open`) and wraps the produced file descriptor into 
  // an instance of this class. Then calls the `block` with the newly created 
  // instance. Once the block exits, the file is closed. 
  // 
  static async open(name: string, mode: string, block: (f: File) => mixed) {
    const file = fileOpen(name, mode)
      .then(fd => new File(fd))
      .disposer((f) => f.close());
    
    await bluebird.using(
      file,
      block); 
  }
  
  constructor(fd: number) {
    this.fd = fd; 
  }
  
  writeln(line: string): Promise<*> {
    return fileWrite(this.fd, line + '\n');
  }
  
  // Closes the file. 
  // 
  close(): Promise<*> {
    return fileClose(this.fd);
  }
}

module.exports = Definition;