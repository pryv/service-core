/**
 * @license
 * Copyright (C) 2012â€“2024 Pryv S.A. https://pryv.com - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 */
const path = require('path');
const fs = require('fs');
const lodash = require('lodash');
const bluebird = require('bluebird');
const protobuf = require('protobufjs');
const protobufLoad = bluebird.promisify(protobuf.load);
// Tools for interacting with a service definition written in protobuf 3.
//

class Definition {
  definitionPath; // original load path for this definition

  root; // protobuf root dictionary
  // Loads a protobuf3 service definition file and returns an instance of
  // `Definition`.
  //
  /** @static
   * @param {string} path
   * @returns {Promise<Definition>}
   */
  static async load (path) {
    const root = await protobufLoad(path);
    return new Definition(path, root);
  }

  constructor (path, root) {
    this.definitionPath = path;
    this.root = root;
  }

  // Compiles this definition into a flow-type signature that describes the
  // protocol and writes a valid flow type signature into the `filename` given.
  // If `path` is also specified, it is used as a target path.
  //
  // The generated definition file will contain interface exports for all
  // relevant types in the definition file so you can annotate the javascript
  // code and make sure your usage corresponds to the current service
  // definition.
  //
  // For example, a protobuf 3 file containing this message:
  //
  //    message SearchResponse {
  //      repeated Result results = 1;
  //    }
  //
  // will compile to:
  //
  //    export interface SearchResponse {
  //      results: Array<Result>;
  //    }
  //
  // Note that your protobuf service description should be closed and not
  // require external types, unless you import those from 'elsewhere.
  //
  /**
   * @param {string} filename
   * @param {string} targetPath
   * @returns {void}
   */
  writeTypeSignature (filename, targetPath) {
    const sigPath = targetPath || path.dirname(this.definitionPath);
    const sigFilename = path.join(sigPath, filename);
    File.open(sigFilename, 'w+', (file) => {
      file.writeln('// @flow');
      file.writeln('');
      file.writeln(`// THIS FILE IS AUTOGENERATED FROM ${this.definitionPath}`);
      file.writeln('// PLEASE DONT EDIT MANUALLY');
      file.writeln('');
      const root = this.root;
      const json = root.toJSON();
      const compiler = new Compiler(file);
      compiler.printFile(json);
    });
  }

  // Looks up the service given by name and returns a ServiceDefinition instance.
  //
  /**
   * @param {string} serviceName
   * @returns {any}
   */
  lookup (serviceName) {
    const root = this.root;
    const service = root.lookup(serviceName);
    return service;
  }

  /**
   * @param {string} serviceName
   * @param {MethodCallback} fn
   * @returns {void}
   */
  forEachMethod (serviceName, fn) {
    const root = this.root;
    const service = root.lookup(serviceName);
    const descriptor = service.toJSON();
    const methods = descriptor.methods;
    if (methods == null) { throw new Error(`No methods in service '${serviceName}', is this really a service?`); }
    for (const key of Object.keys(methods)) {
      const method = methods[key];
      const requestType = root.lookup(method.requestType);
      const responseType = root.lookup(method.responseType);
      fn(key, requestType, responseType);
    }
  }
}
// Compiles a json description of a .proto file to file output that can be
// written into a .js file.
//

class Compiler {
  enumValues; // all enums we encounter

  file;
  constructor (file) {
    this.file = file;
    this.enumValues = new Map();
  }

  // Prints a whole .proto definition file
  /**
   * @returns {void}
   */
  printFile (json) {
    this.printTypes(json);
    this.exportEnums();
  }

  // Prints a list of types that are nested in a definition.
  /**
   * @returns {void}
   */
  printTypes (json) {
    this.printObject(json.nested, (key, type) => {
      this.printType(key, type);
    });
  }

  // Prints a single type.
  /**
   * @returns {void}
   */
  printType (name, json) {
    if (json.nested != null) { this.printTypes(json); }
    if (json.values != null) { // Assume any other type, output as an interface.
      this.printTypeAsEnum(name, json);
    } else { this.printTypeAsInterface(name, json); }
  }

  /**
   * @returns {void}
   */
  printTypeAsInterface (name, json) {
    const file = this.file;
    file.writeln(`export interface ${this.translateToInterface(name)} {`);
    this.printObject(json.fields, (key, field) => {
      file.writeln(`  ${key}: ${this.translateType(field)};  // id = ${field.id}`);
    });
    this.printObject(json.methods, (name, method) => {
      const methodName = lodash.lowerFirst(name);
      const requestType = this.translateToInterface(method.requestType);
      const responseInnerType = this.translateToInterface(method.responseType);
      file.writeln(`  ${methodName}(req: ${requestType}): Promise<${responseInnerType}>;`);
    });
    file.writeln('}');
  }

  /**
   * @returns {void}
   */
  printTypeAsEnum (name, json) {
    const file = this.file;
    if (json.values == null) { throw new Error("AF: doesn't look like an enum..."); }
    const values = [];
    file.writeln(`const ${name} = {`);
    this.printObject(json.values, (key, value) => {
      file.writeln(`  ${key}: ${value.toString()},`);
      values.push(value);
    });
    file.writeln('};');
    // Remember all enums here:
    this.enumValues.set(name, new Set(values));
  }

  // Generic object printer.
  /**
   * @param {(b: string, a: any) => unknown} fn
   * @returns {void}
   */
  printObject (obj, fn) {
    if (obj != null) {
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        fn(key, value);
      }
    }
  }

  // Translates a type to an interface, if needed.
  /**
   * @param {string} name
   * @returns {string}
   */
  translateToInterface (name) {
    const enumValues = this.enumValues;
    if (enumValues.has(name)) {
      const values = enumValues.get(name);
      if (values == null) { throw new Error('AF: Enum must not be empty.'); }
      return this.allowedEnumValues(values);
    }
    switch (name) {
      case 'string':
        return 'string';
      case 'int32':
      case 'int64':
      case 'uint32':
      case 'uint64':
        return 'number';
      case 'double':
        return 'number';
      case 'bool':
        return 'boolean';
      default:
        // Assuming name is a constructed type as well.
        return `I${name}`;
    }
    // NOT REACHED
  }

  // Translates a type to the aequivalent flow-type type.
  /**
   * @param {any} field
   * @returns {string}
   */
  translateType (field) {
    let output = this.translateToInterface(field.type);
    if (field.rule === 'repeated') {
      output = `Array<${output}>`;
    }
    return output;
  }

  // Returns all the values that are allowed for an enum as a string.
  /**
   * @param {Set<any>} values
   * @returns {string}
   */
  allowedEnumValues (values) {
    return Array.from(values)
      .map((e) => e.toString())
      .join(' | ');
  }

  /**
   * @returns {void}
   */
  exportEnums () {
    const file = this.file;
    if (this.enumValues.size > 0) {
      const enums = Array.from(this.enumValues.keys()).join(', ');
      file.writeln(`module.exports = { ${enums} };`);
    }
  }
}
// A thin wrapper around 'fs', doing resource disposal.
//

class File {
  fd; // The file descriptor returned by fs.open.
  // Opens a file (`fs.open`) and wraps the produced file descriptor into
  // an instance of this class. Then calls the `block` with the newly created
  // instance. Once the block exits, the file is closed.
  //
  /** @static
   * @param {string} name
   * @param {string} mode
   * @param {(f: File) => unknown} block
   * @returns {void}
   */
  static open (name, mode, block) {
    const fd = fs.openSync(name, mode);
    const file = new File(fd);
    block(file);
    file.close();
  }

  constructor (fd) {
    this.fd = fd;
  }

  /**
   * @param {string} line
   * @returns {any}
   */
  writeln (line) {
    return fs.writeSync(this.fd, line + '\n');
  }

  // Closes the file.
  //
  /**
   * @returns {void}
   */
  close () {
    fs.closeSync(this.fd);
  }
}
module.exports = Definition;

/** @typedef {any} PBNamespace */

/** @typedef {any} PBType */

/** @typedef {(name: string, req: PBType, res: PBType) => unknown} MethodCallback */
