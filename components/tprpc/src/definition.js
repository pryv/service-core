// @flow

const path = require('path');
const fs = require('fs');

const bluebird = require('bluebird');

const protobuf = require('protobufjs');
const protobufLoad = bluebird.promisify(protobuf.load);

type DefinitionRoot = mixed; 

// Tools for interacting with a service definition written in protobuf 3. 
// 
class Definition {
  definitionPath: string;       // original load path for this definition
  root: DefinitionRoot;         // protobuf root dictionary
  
  // Loads a protobuf3 service definition file and returns an instance of
  // `Definition`.
  // 
  static load(path: string): Definition {
    const root = protobufLoad(path);
    return new Definition(path, root); 
  }

  constructor(path: string, root: DefinitionRoot) {
    this.definitionPath = path; 
    this.root = root;
  }
  
  // Compiles this definition into a flow-type signature that describes the
  // protocol and writes a valid flow type signature into the `filename` given.
  // If `path` is also specified, it is used as a target path. 
  // 
  // The generated definition file will contain interface exports for all
  // relevant types in the definition file so you can annotate the javascript
  // code and make sure your usage corresponds to the current service
  // definition. 
  // 
  // For example, a protobuf 3 file containing this message: 
  // 
  //    message SearchResponse {
  //      repeated Result results = 1;
  //    }
  // 
  // will compile to: 
  // 
  //    export interface SearchResponse {
  //      results: Array<Result>;
  //    }
  // 
  // Note that your protobuf service description should be closed and not
  // require external types, unless you import those from elsewhere. 
  // 
  writeTypeSignature(filename: string, targetPath?: string) {
    const sigPath = targetPath || path.dirname(this.definitionPath);
    const sigFilename = path.join(sigPath, filename);
    
    File.open(sigFilename, 'w+', (file) => {
      file.writeln('// @flow');
      file.writeln('');
      file.writeln(`// THIS FILE IS AUTOGENERATED FROM ${this.definitionPath}`);
      file.writeln('// PLEASE DONT EDIT MANUALLY');
      file.writeln('');
    });
  }
}

// A thin wrapper around 'fs', doing resource disposal. 
// 
class File {
  fd: number;         // The file descriptor returned by fs.open. 
  
  // Opens a file (`fs.open`) and wraps the produced file descriptor into 
  // an instance of this class. Then calls the `block` with the newly created 
  // instance. Once the block exits, the file is closed. 
  // 
  static open(name: string, mode: string, block: (f: File) => mixed) {
    const fd = fs.openSync(name, mode);
    const file = new File(fd);
    
    block(file);
    
    file.close(); 
  }
  
  constructor(fd: number) {
    this.fd = fd; 
  }
  
  writeln(line: string) {
    return fs.writeSync(this.fd, line + '\n');
  }
  
  // Closes the file. 
  // 
  close() {
    fs.closeSync(this.fd);
  }
}

module.exports = Definition;