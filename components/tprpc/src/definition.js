// @flow

const path = require('path');
const fs = require('fs');
const lodash = require('lodash');

const bluebird = require('bluebird');

const protobuf = require('protobufjs');

const protobufLoad = bluebird.promisify(protobuf.load);

type PBNamespace = any;
type PBType = any;
type MethodCallback = (name: string, req: PBType, res: PBType) => mixed;

// Tools for interacting with a service definition written in protobuf 3.
//
class Definition {
  definitionPath: string; // original load path for this definition

  root: PBNamespace; // protobuf root dictionary

  // Loads a protobuf3 service definition file and returns an instance of
  // `Definition`.
  //
  static async load(path: string): Promise<Definition> {
    const root = await protobufLoad(path);
    return new Definition(path, root);
  }

  constructor(path: string, root: PBNamespace) {
    this.definitionPath = path;
    this.root = root;
  }

  // Compiles this definition into a flow-type signature that describes the
  // protocol and writes a valid flow type signature into the `filename` given.
  // If `path` is also specified, it is used as a target path.
  //
  // The generated definition file will contain interface exports for all
  // relevant types in the definition file so you can annotate the javascript
  // code and make sure your usage corresponds to the current service
  // definition.
  //
  // For example, a protobuf 3 file containing this message:
  //
  //    message SearchResponse {
  //      repeated Result results = 1;
  //    }
  //
  // will compile to:
  //
  //    export interface SearchResponse {
  //      results: Array<Result>;
  //    }
  //
  // Note that your protobuf service description should be closed and not
  // require external types, unless you import those from elsewhere.
  //
  writeTypeSignature(filename: string, targetPath?: string) {
    const sigPath = targetPath || path.dirname(this.definitionPath);
    const sigFilename = path.join(sigPath, filename);

    File.open(sigFilename, 'w+', (file) => {
      file.writeln('// @flow');
      file.writeln('');
      file.writeln(`// THIS FILE IS AUTOGENERATED FROM ${this.definitionPath}`);
      file.writeln('// PLEASE DONT EDIT MANUALLY');
      file.writeln('');

      const { root } = this;
      const json = root.toJSON();

      const compiler = new Compiler(file);
      compiler.printFile(json);
    });
  }

  // Looks up the service given by name and returns a ServiceDefinition instance.
  //
  lookup(serviceName: string): PBType {
    const { root } = this;
    const service = root.lookup(serviceName);
    return service;
  }

  forEachMethod(serviceName: string, fn: MethodCallback): void {
    const { root } = this;
    const service = root.lookup(serviceName);
    const descriptor = service.toJSON();
    const { methods } = descriptor;

    if (methods == null) { throw new Error(`No methods in service '${serviceName}', is this really a service?`); }

    for (const key of Object.keys(methods)) {
      const method = methods[key];

      const requestType = root.lookup(method.requestType);
      const responseType = root.lookup(method.responseType);

      fn(key, requestType, responseType);
    }
  }
}

// Compiles a json description of a .proto file to file output that can be
// written into a .js file.
//
class Compiler {
  enumValues: Map<string, Set<Object>>; // all enums we encounter

  file: File;

  constructor(file) {
    this.file = file;
    this.enumValues = new Map();
  }

  // Prints a whole .proto definition file
  printFile(json) {
    this.printTypes(json);
    this.exportEnums();
  }

  // Prints a list of types that are nested in a definition.
  printTypes(json) {
    this.printObject(json.nested, (key, type) => {
      this.printType(key, type);
    });
  }

  // Prints a single type.
  printType(name, json) {
    if (json.nested != null) this.printTypes(json);

    if (json.values != null) { this.printTypeAsEnum(name, json); } else // Assume any other type, output as an interface.
    { this.printTypeAsInterface(name, json); }
  }

  printTypeAsInterface(name, json) {
    const { file } = this;

    file.writeln(`export interface ${this.translateToInterface(name)} {`);

    this.printObject(json.fields, (key, field) => {
      file.writeln(`  ${key}: ${this.translateType(field)};  // id = ${field.id}`);
    });

    this.printObject(json.methods, (name, method) => {
      const methodName = lodash.lowerFirst(name);
      const requestType = this.translateToInterface(method.requestType);
      const responseInnerType = this.translateToInterface(method.responseType);

      file.writeln(`  ${methodName}(req: ${requestType}): Promise<${responseInnerType}>;`);
    });

    file.writeln('}');
  }

  printTypeAsEnum(name, json) {
    const { file } = this;
    if (json.values == null) throw new Error("AF: doesn't look like an enum...");

    const values = [];

    file.writeln(`const ${name} = {`);
    this.printObject(json.values, (key, value) => {
      file.writeln(`  ${key}: ${value.toString()},`);

      values.push(value);
    });
    file.writeln('};');

    // Remember all enums here:
    this.enumValues.set(name, new Set(values));
  }

  // Generic object printer.
  printObject(obj, fn: (string, Object) => mixed) {
    if (obj != null) {
      for (const key of Object.keys(obj)) {
        const value = obj[key];

        fn(key, value);
      }
    }
  }

  // Translates a type to an interface, if needed.
  translateToInterface(name: string): string {
    const { enumValues } = this;

    if (enumValues.has(name)) {
      const values = enumValues.get(name);
      if (values == null) throw new Error('AF: Enum must not be empty.');
      return this.allowedEnumValues(values);
    }

    switch (name) {
      case 'string': return 'string';

      case 'int32':
      case 'int64':
      case 'uint32':
      case 'uint64': return 'number';
      case 'double': return 'number';

      case 'bool': return 'boolean';

      default:
      // Assuming name is a constructed type as well.
        return `I${name}`;
    }
    // NOT REACHED
  }

  // Translates a type to the aequivalent flow-type type.
  translateType(field: Object): string {
    let output = this.translateToInterface(field.type);
    if (field.rule === 'repeated') {
      output = `Array<${output}>`;
    }
    return output;
  }

  // Returns all the values that are allowed for an enum as a string.
  allowedEnumValues(values: Set<Object>) {
    return Array.from(values)
      .map((e) => e.toString())
      .join(' | ');
  }

  exportEnums() {
    const { file } = this;

    if (this.enumValues.size > 0) {
      const enums = Array.from(this.enumValues.keys()).join(', ');
      file.writeln(`module.exports = { ${enums} };`);
    }
  }
}

// A thin wrapper around 'fs', doing resource disposal.
//
class File {
  fd: number; // The file descriptor returned by fs.open.

  // Opens a file (`fs.open`) and wraps the produced file descriptor into
  // an instance of this class. Then calls the `block` with the newly created
  // instance. Once the block exits, the file is closed.
  //
  static open(name: string, mode: string, block: (f: File) => mixed) {
    const fd = fs.openSync(name, mode);
    const file = new File(fd);

    block(file);

    file.close();
  }

  constructor(fd: number) {
    this.fd = fd;
  }

  writeln(line: string) {
    return fs.writeSync(this.fd, `${line}\n`);
  }

  // Closes the file.
  //
  close() {
    fs.closeSync(this.fd);
  }
}

module.exports = Definition;
