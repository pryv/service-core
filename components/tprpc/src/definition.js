// @flow

const path = require('path');
const fs = require('fs');
const lodash = require('lodash');

const bluebird = require('bluebird');

const protobuf = require('protobufjs');
const protobufLoad = bluebird.promisify(protobuf.load);

type PBNamespace = any; 
type PBType = any; 

// Tools for interacting with a service definition written in protobuf 3. 
// 
class Definition {
  definitionPath: string;           // original load path for this definition
  root: PBNamespace;                // protobuf root dictionary
  
  // Loads a protobuf3 service definition file and returns an instance of
  // `Definition`.
  // 
  static async load(path: string): Promise<Definition> {
    const root = await protobufLoad(path);
    return new Definition(path, root); 
  }

  constructor(path: string, root: PBNamespace) {
    this.definitionPath = path; 
    this.root = root;
  }
  
  // Compiles this definition into a flow-type signature that describes the
  // protocol and writes a valid flow type signature into the `filename` given.
  // If `path` is also specified, it is used as a target path. 
  // 
  // The generated definition file will contain interface exports for all
  // relevant types in the definition file so you can annotate the javascript
  // code and make sure your usage corresponds to the current service
  // definition. 
  // 
  // For example, a protobuf 3 file containing this message: 
  // 
  //    message SearchResponse {
  //      repeated Result results = 1;
  //    }
  // 
  // will compile to: 
  // 
  //    export interface SearchResponse {
  //      results: Array<Result>;
  //    }
  // 
  // Note that your protobuf service description should be closed and not
  // require external types, unless you import those from elsewhere. 
  // 
  writeTypeSignature(filename: string, targetPath?: string) {
    const sigPath = targetPath || path.dirname(this.definitionPath);
    const sigFilename = path.join(sigPath, filename);
    
    File.open(sigFilename, 'w+', file => {
      file.writeln('// @flow');
      file.writeln('');
      file.writeln(`// THIS FILE IS AUTOGENERATED FROM ${this.definitionPath}`);
      file.writeln('// PLEASE DONT EDIT MANUALLY');
      file.writeln('');
      
      const root = this.root; 
      const json = root.toJSON();
      printTypes(file, json);
    });
  }

  // Looks up the service given by name and returns a ServiceDefinition instance. 
  // 
  lookup(serviceName: string): PBType {
    const root = this.root; 
    const service = root.lookup(serviceName);
    return service;
  }
}

function printTypes(file, json) {
  printObject(json.nested, (key, type) => {
    file.writeln(`export interface ${translateToInterface(key)} {`);
    printType(file, type);
    file.writeln('}');
  });
}
function printType(file, json) {
  printObject(json.fields, (key, field) => {
    file.writeln(`  ${key}: ${translateType(field)};  // id = ${field.id}`);
  });

  printObject(json.methods, (name, method) => {
    file.writeln(`  ${lodash.lowerFirst(name)}(req: ${translateToInterface(method.requestType)}): ${translateToInterface(method.responseType)};`);
  });
}
function printObject(obj, fn: (string, Object) => mixed) {
  if (obj != null) {
    for (const key of Object.keys(obj)) {
      const value = obj[key];
      
      fn(key, value);
    }
  }
}
function translateToInterface(name: string): string {
  return `I${name}`;
}
function translateType(field: Object): string {
  let output = translateToInterface(field.type); 
  if (field.rule === 'repeated') {
    output = `Array<${output}>`;
  }
  return output;
}

// A thin wrapper around 'fs', doing resource disposal. 
// 
class File {
  fd: number;         // The file descriptor returned by fs.open. 
  
  // Opens a file (`fs.open`) and wraps the produced file descriptor into 
  // an instance of this class. Then calls the `block` with the newly created 
  // instance. Once the block exits, the file is closed. 
  // 
  static open(name: string, mode: string, block: (f: File) => mixed) {
    const fd = fs.openSync(name, mode);
    const file = new File(fd);
    
    block(file);
    
    file.close(); 
  }
  
  constructor(fd: number) {
    this.fd = fd; 
  }
  
  writeln(line: string) {
    return fs.writeSync(this.fd, line + '\n');
  }
  
  // Closes the file. 
  // 
  close() {
    fs.closeSync(this.fd);
  }
}

module.exports = Definition;