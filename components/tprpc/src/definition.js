// @flow

const path = require('path');
const fs = require('fs');
const lodash = require('lodash');

const bluebird = require('bluebird');

const protobuf = require('protobufjs');
const protobufLoad = bluebird.promisify(protobuf.load);

type PBNamespace = any; 
type PBType = any;
type MethodCallback = (name: string, req: PBType, res: PBType) => mixed;

// Tools for interacting with a service definition written in protobuf 3. 
// 
class Definition {
  definitionPath: string;           // original load path for this definition
  root: PBNamespace;                // protobuf root dictionary
  
  // Loads a protobuf3 service definition file and returns an instance of
  // `Definition`.
  // 
  static async load(path: string): Promise<Definition> {
    const root = await protobufLoad(path);
    return new Definition(path, root); 
  }

  constructor(path: string, root: PBNamespace) {
    this.definitionPath = path; 
    this.root = root;
  }
  
  // Compiles this definition into a flow-type signature that describes the
  // protocol and writes a valid flow type signature into the `filename` given.
  // If `path` is also specified, it is used as a target path. 
  // 
  // The generated definition file will contain interface exports for all
  // relevant types in the definition file so you can annotate the javascript
  // code and make sure your usage corresponds to the current service
  // definition. 
  // 
  // For example, a protobuf 3 file containing this message: 
  // 
  //    message SearchResponse {
  //      repeated Result results = 1;
  //    }
  // 
  // will compile to: 
  // 
  //    export interface SearchResponse {
  //      results: Array<Result>;
  //    }
  // 
  // Note that your protobuf service description should be closed and not
  // require external types, unless you import those from elsewhere. 
  // 
  writeTypeSignature(filename: string, targetPath?: string) {
    const sigPath = targetPath || path.dirname(this.definitionPath);
    const sigFilename = path.join(sigPath, filename);
    
    File.open(sigFilename, 'w+', file => {
      file.writeln('// @flow');
      file.writeln('');
      file.writeln(`// THIS FILE IS AUTOGENERATED FROM ${this.definitionPath}`);
      file.writeln('// PLEASE DONT EDIT MANUALLY');
      file.writeln('');
      
      const root = this.root; 
      const json = root.toJSON();
      
      const compiler = new Compiler(file); 
      compiler.printFile(json);
    });
  }

  // Looks up the service given by name and returns a ServiceDefinition instance. 
  // 
  lookup(serviceName: string): PBType {
    const root = this.root; 
    const service = root.lookup(serviceName);
    return service;
  }

  forEachMethod(serviceName: string, fn: MethodCallback): void {
    const root = this.root; 
    const service = root.lookup(serviceName);
    const descriptor = service.toJSON();
    const methods: Object = descriptor.methods; 
    
    if (methods == null) 
      throw new Error(`No methods in service '${serviceName}', is this really a service?`);
      
    for (const key of Object.keys(methods)) {
      const method = methods[key];
      
      const requestType = root.lookup(method.requestType); 
      const responseType = root.lookup(method.responseType);
      
      fn(key, requestType, responseType);
    }
  }
}

// Compiles a json description of a .proto file to file output that can be
// written into a .js file. 
// 
class Compiler {
  enumValues: Map<string, Set<Object>>; // all enums we encounter
  file: File;
  
  constructor(file) {
    this.file = file;
    this.enumValues = new Map(); 
  }
  
  // Prints a whole .proto definition file
  printFile(json) {
    this.printTypes(json);
    this.exportEnums(); 
  }
  // Prints a list of types that are nested in a definition. 
  printTypes(json) {
    this.printObject(json.nested, (key, type) => {
      this.printType(key, type);
    });
  }
  // Prints a single type. 
  printType(name, json) {
    if (json.nested != null) this.printTypes(json);

    if (json.values != null) 
      this.printTypeAsEnum(name, json);
    else // Assume any other type, output as an interface. 
      this.printTypeAsInterface(name, json);
  }
  printTypeAsInterface(name, json) {
    const file = this.file; 
    
    file.writeln(`export interface ${this.translateToInterface(name)} {`);

    this.printObject(json.fields, (key, field) => {
      file.writeln(`  ${key}: ${this.translateType(field)};  // id = ${field.id}`);
    });

    this.printObject(json.methods, (name, method) => {
      const methodName = lodash.lowerFirst(name);
      const requestType = this.translateToInterface(method.requestType);
      const responseInnerType = this.translateToInterface(method.responseType);
      
      file.writeln(`  ${methodName}(req: ${requestType}): Promise<${responseInnerType}>;`);
    });

    file.writeln('}');
  }
  printTypeAsEnum(name, json) {
    const file = this.file; 
    if (json.values == null) throw new Error("AF: doesn't look like an enum...");
    
    const values = []; 
    
    file.writeln(`const ${name} = {`);
    this.printObject(json.values, (key, value) => {
      file.writeln(`  ${key}: ${value.toString()},`);
      
      values.push(value);
    });
    file.writeln('};');
    
    // Remember all enums here: 
    this.enumValues.set(name, new Set(values));
  }
  // Generic object printer. 
  printObject(obj, fn: (string, Object) => mixed) {
    if (obj != null) {
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        
        fn(key, value);
      }
    }
  }
  // Translates a type to an interface, if needed. 
  translateToInterface(name: string): string {
    const enumValues = this.enumValues;
    
    if (enumValues.has(name)) {
      const values = enumValues.get(name);
      if (values == null) throw new Error('AF: Enum must not be empty.');
      return this.allowedEnumValues(values);
    }
    
    switch (name) {
      case 'string': return 'string';
      case 'int32': 
      case 'int64': 
      case 'uint32': 
      case 'uint64': return 'number';
      
      default:
      // Assuming name is a constructed type as well. 
        return `I${name}`;  
    }
    // NOT REACHED
  }
  // Translates a type to the aequivalent flow-type type. 
  translateType(field: Object): string {
    let output = this.translateToInterface(field.type); 
    if (field.rule === 'repeated') {
      output = `Array<${output}>`;
    }
    return output;
  }
  // Returns all the values that are allowed for an enum as a string. 
  allowedEnumValues(values: Set<Object>) {
    return Array.from(values)
      .map(e => e.toString())
      .join(' | ');
  }

  exportEnums() {
    const file = this.file; 

    if (this.enumValues.size > 0) {
      const enums = Array.from(this.enumValues.keys()).join(', ');
      file.writeln(`module.exports = { ${enums} };`);
    }
  }
}

// A thin wrapper around 'fs', doing resource disposal. 
// 
class File {
  fd: number;         // The file descriptor returned by fs.open. 
  
  // Opens a file (`fs.open`) and wraps the produced file descriptor into 
  // an instance of this class. Then calls the `block` with the newly created 
  // instance. Once the block exits, the file is closed. 
  // 
  static open(name: string, mode: string, block: (f: File) => mixed) {
    const fd = fs.openSync(name, mode);
    const file = new File(fd);
    
    block(file);
    
    file.close(); 
  }
  
  constructor(fd: number) {
    this.fd = fd; 
  }
  
  writeln(line: string) {
    return fs.writeSync(this.fd, line + '\n');
  }
  
  // Closes the file. 
  // 
  close() {
    fs.closeSync(this.fd);
  }
}

module.exports = Definition;